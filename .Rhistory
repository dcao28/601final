getwd()
setwd("~")
getwd()
check("robust")#copy from http://pages.stat.wisc.edu/~jgillett/327-3/2package/jgUtilities/DESCRIPTION
library(devtools)
check("robust")#copy from http://pages.stat.wisc.edu/~jgillett/327-3/2package/jgUtilities/DESCRIPTION
build("robust")
install.packages("/Users/CDX/robust_0.1.tar.gz",repos = NULL,type = "source")
library(cdx)
library(robust)
method(lad)
methods(lad)
lad
area
lad(area$land,area$farm)
check("robust")#copy from http://pages.stat.wisc.edu/~jgillett/327-3/2package/jgUtilities/DESCRIPTION
build("robust")
install.packages("/Users/CDX/robust_0.1.tar.gz",repos = NULL,type = "source")
library(robust)
lad(area$land,area$farm)
methods(print)
print.lad
check("robust")#copy from http://pages.stat.wisc.edu/~jgillett/327-3/2package/jgUtilities/DESCRIPTION
check("robust")#copy from http://pages.stat.wisc.edu/~jgillett/327-3/2package/jgUtilities/DESCRIPTION
build("robust")
install.packages("/Users/CDX/robust_0.1.tar.gz",repos = NULL,type = "source")
library(robust)
a<-lad(area$land,area$farm)
a
predict(a,4)
predict(a,6)
predict(a,1:4)
coef(a)
abline(a)
a
coef(a)
b<-lm(farm~land,area)
abline(b)
plot.new()
abline(b)
plot(area$land,area$farm)
abline(b)
abline(a)
predict(a,quantile(area$land,c(0,.25,.5,.75,1)))
quantile(area$land,c(0,.25,.5,.75,1))
check("robust")#copy from http://pages.stat.wisc.edu/~jgillett/327-3/2package/jgUtilities/DESCRIPTION
build("robust")
install.packages("/Users/CDX/robust_0.1.tar.gz",repos = NULL,type = "source")
library(robust)
example(lad)
library(robust)
?lad
example(lad)
check("robust")#copy from http://pages.stat.wisc.edu/~jgillett/327-3/2package/jgUtilities/DESCRIPTION
library(devtools)
check("robust")#copy from http://pages.stat.wisc.edu/~jgillett/327-3/2package/jgUtilities/DESCRIPTION
build("robust")
install.packages("/Users/CDX/robust_0.1.tar.gz",repos = NULL,type = "source")
library(robust)
example(lad)
library(robust)
lad
example(lad)
?print.lad
?coef.lad
?print.lad
?predict.lad
library("robust", lib.loc="/Library/Frameworks/R.framework/Versions/3.2/Resources/library")
remove.packages("robust")
install.packages("/Users/CDX/WISC_R_HWK/R327/robust_0.1.tar.gz",repos = NULL,type="source")
example(lad)
require(robust)
example(lad)''
example(lad)
remove.packages("robust")
install.packages("/Users/CDX/WISC_R_HWK/R327/robust_0.1.tar.gz",repos = NULL,type="source")
library(robust)
lad
example(lad)
getwd
getwd()
check("robust")#copy from http://pages.stat.wisc.edu/~jgillett/327-3/2package/jgUtilities/DESCRIPTION
library(devtools)
check("robust")#copy from http://pages.stat.wisc.edu/~jgillett/327-3/2package/jgUtilities/DESCRIPTION
build("robust")
remove.packages("robust")
install.packages("/Users/CDX/robust_0.1.tar.gz",repos = NULL,type = "source")
library(robust)
example(lad)
library(robust)
example(lad)
library(lad)
library(robust)
lad
lad(area$land,area$farm)
a<-lad(area$land,area$farm)
predict(a,3)
print(a)
coef(a)
example(lad)
library(robust)
example(lad)
remove.packages("robust")
install.packages("/Users/CDX/robust_0.1.tar.gz",repos = NULL,type = "source")
example(lad)
a<-lad(area$land,area$farm)
coef(a)
example(lad)
example(lad)
a<-lad(area$land,area$farm)
coef(a)
example(lad)
remove.packages("robust")
install.packages("/Users/CDX/robust_0.1.tar.gz",repos = NULL,type = "source")
library(robust)
example(lad)
.rdb' is corrupt
getwd()
check(robust)
heck(robust)
library(devtools)
check(robust)
check("robust")
check("robust")
build("robust")
install.packages("/Users/CDX/robust_0.1.tar.gz",repos = NULL,type = "source")
library(robust)
example()
example(lad)
library(robust)
example(lad)
library(robust)
example(lad)
remove.packages("robust")
install.packages("/Users/CDX/robust_0.1.tar.gz",repos = NULL,type = "source")
require(robust)
example(robust)
require(robust)
example(lad)
?scake
?scale
scale(c(1,2,3,4))
((1:4)-2.5)/sd(1:4)
?princomp
address <- "http://www.stat.wisc.edu/~gvludwig/fall_2012/midterm2_problem1.csv"
PM2.5 <- read.csv(address, header=TRUE)
summary(model <- lm(log(PM) ~ LAT + LON + MAX + MIN + PCP + N1 + S1 + A1 + C1 + F1
summary(model <- lm(log(PM) ~ LAT + LON + MAX + MIN + PCP + N1 + S1 + A1 + C1 + F
summary(model <- lm(log(PM) ~ LAT + LON + MAX + MIN + PCP + N1 + S1 + A1 + C1 + F1                    + I1, data = PM2.5)
summary(model <- lm(log(PM) ~ LAT + LON + MAX + MIN + PCP + N1 + S1 + A1 + C1 + F1+ I1, data = PM2.5)
)
X <- model.matrix(model)[,-1]
pc.cr <-princomp(scale(X))
plot(pc.cr)
pc.cr$loadings
pc.cr$loadings
x<-scale(X[,-1])
eigen(t(x)%*%x)$vectors
x<-scale(X)
eigen(t(x)%*%x)$vectors
pc.cr$loadings
svdx<-svd(x)
svdx$v
eigen(t(x)%*%x)$vectors
?eigen
?princomp
?svd
?eigen
eigen(t(x)%*%x)$vec
eigen(t(x)%*%x)$vectors
eigen(t(x)%*%x)$vec
library(rugarch)
?ugarchforecast
library(forecast)
?HoltWinters
?optim
install.packages("RSPerl")
install.packages()
install.packages("mcmc")
install.packages("coda")
?mcmc
help(mcmc)
help("mcmc")
install.packages("R2WinBUGS")
library(R2WinBUGS)
?bugs
data(schools)
schools
J <- nrow(schools)
y <- schools$estimate
sigma.y <- schools$sd
data <- list(J=J, y=y, sigma.y=sigma.y)
inits <- function(){
list(theta=rnorm(J, 0, 100), mu.theta=rnorm(1, 0, 100),
sigma.theta=runif(1, 0, 100))
}
parameters <- c("theta", "mu.theta", "sigma.theta")
model.file <- system.file(package="R2WinBUGS", "model", "schools.txt")
schools.sim <- bugs(data, inits, parameters, model.file,
n.chains=3, n.iter=5000,
bugs.directory="/Applications/OpenBUGS/OpenBUGS323",
working.directory = ".",
WINE="usr/local/Cellar/wine/1.6.2/bin/wine",
WINEPATH="usr/local/Cellar/wine/1.6.2/bin/winepath")
schools.sim <- bugs(data, inits, parameters, model.file,
n.chains=3, n.iter=5000,
bugs.directory="/Applications/OpenBUGS/OpenBUGS323",
working.directory = ".",
WINE="usr/local/bin/wine",
WINEPATH="usr/local/bin/winepath")
schools.sim <- bugs(data, inits, parameters, model.file,
n.chains=3, n.iter=5000,
bugs.directory="/Applications/OpenBUGS/OpenBUGS323",
working.directory = ".",
useWINE=TRUE,
WINE="/usr/local/bin/wine",
WINEPATH="/usr/local/bin/winepath")
schools.sim <- bugs(data, inits, parameters, model.file,
n.chains=3, n.iter=5000,
bugs.directory="~/.wine/drive_c/Program Files/OpenBUGS",
working.directory = ".",
useWINE=TRUE,
WINE="/usr/local/bin/wine",
WINEPATH="/usr/local/bin/winepath")
data(schools)
#define the model
nummodel <- function(){
for (j in 1:J){
y[j] ~ dnorm (theta[j], tau.y[j])
theta[j] ~ dnorm (mu.theta, tau.theta)
tau.y[j] <- pow(sigma.y[j], -2)}
mu.theta ~ dnorm (0.0, 1.0E-6)
tau.theta <- pow(sigma.theta, -2)
sigma.theta ~ dunif (0, 1000)
}
# write the model code out to a file
write.model(nummodel, "nummodel.txt")
model.file1 = paste(getwd(),"nummodel.txt", sep="/")
## and let's take a look:
file.show("nummodel.txt")
J <- nrow(schools)
y <- schools$estimate
sigma.y <- schools$sd
data <- list ("J", "y", "sigma.y")
#initialization of variables
inits <- function(){
list(theta = rnorm(J, 0, 100), mu.theta = rnorm(1, 0, 100), sigma.theta = runif(1, 0, 100))}
#set the WINE working directory and the directory to OpenBUGS - change the OpenBUGS.exe location as necessary
WINE="/usr/local/bin/wine"
WINEPATH="/usr/local/bin/winepath"
OpenBUGS.pgm="/Users/CDX/.wine/drive_c/Program Files/OpenBUGS/OpenBUGS323/OpenBUGS.exe"
#these are the parameters to save
parameters = c("theta", "mu.theta", "sigma.theta")
#run the model
schools.sim <- bugs(data, inits, model.file = model.file1,parameters=parameters,n.chains = 3, n.iter = 1000, OpenBUGS.pgm=OpenBUGS.pgm, WINE=WINE, WINEPATH=WINEPATH,useWINE=T)
install.packages("R2OpenBUGS")
library(R2OpenBUGS)
schools.sim <- bugs(data, inits, model.file = model.file1,parameters=parameters,n.chains = 3, n.iter = 1000,
OpenBUGS.pgm=OpenBUGS.pgm, WINE=WINE, WINEPATH=WINEPATH,useWINE=T)
print(schools.sim)
remove.packages("R2WinBUGS")
getwd()
library(parallel)
detectCores()
lapply(1:5,function(x) x+2)
system.time(mclapply(1:5,function(x) x+2,mc.cores = 1))
system.time(mclapply(1:5,function(x) x+2,mc.cores = 4))
system.time(lapply(1:5,function(x) x+2))
system.time(mclapply(1:5,function(x) x+2,mc.cores = 1))
system.time(lapply(1:5,function(x) x+2))
system.time(mclapply(1:5,function(x) x+2,mc.cores = 4))
?"parLapply"
?"parallel-package"
?"paralle"
1:160000
d<-1:160000
cut(d,seq(d,d/4))
cut(d,seq(d,by=d/4))
cut(d,seq(d,by=160000/4))
?mcmapply
?mapply
?mcmapply
N=40
cut(1:N,seq(1:N,by = N/4))
cut(1:N,seq(1,N,by = N/4))
cut(0:N,seq(1,N,by = N/4))
cut(1:N,seq(0,N,by = N/4))
data("mtcars")
head(mtcars)
names(mtcars)
m1 <- lm.ridge(mpg~ cyl+disp+hp,lambda = seq(0,10,0.01))
install.packages("alr3")
library(alr3)
m1 <- lm.ridge(mpg~ cyl+disp+hp,lambda = seq(0,10,0.01))
library(MASS)
m1 <- lm.ridge(mpg~ cyl+disp+hp,lambda = seq(0,10,0.01))
library(MASS)
m1 <- lm.ridge(mpg~ cyl+disp+hp,lambda = seq(0,10,0.01))
?lm.ridge
m1 <- lm.ridge(mpg~ cyl+disp+hp,data = mtcars,lambda = seq(0,10,0.01))
?select
select(m1)
class(m1)
methods(select)
methods("select")
rm(list = ls())
setwd("~/601final")
library(xlsx)
## data preprocessing
set_b = read.csv("data/Set_b.csv", header = TRUE)
set_c = read.csv("data/Set_c.csv", header = TRUE) # set c has TP53
tp53 = read.xlsx("data/TP53.xlsx",sheetIndex = 1)##TP53
set_b = set_b[-which(set_b$response == 0),]
set_c = set_c[-which(set_c$response == 0),] # delete y=0
set_b_scale = data.frame(scale(set_b[,-1]))
set_b_scale$response = set_b$response
set_c_scale = data.frame(scale(set_c[,-1]))
set_c_scale$response = set_c$response # scale X
tp53 =tp53[-which(tp53$response == 0),] # delete the observation which has response equal to 0
tp53_scale = data.frame(scale(tp53[,-1]))
#View(set_c);View(set_b)
set_combine<-merge(set_b,set_c)
# set_combine = set_b
# set_combine[,length(set_b):(length(set_b)+length(set_c))] = set_c
set_combine_scale = data.frame(scale(set_combine[,-1]))
set_combine_scale$response = set_combine$response
# name_b = names(set_b_scale)
# name_c = names(set_c_scale)
# a = rep(0, length(name_c))
# for(i in 1:length(name_b)){
#   for(j in 1:length(name_c)){
#     if(name_c[j] == name_b[i]){
#       a[j] = 1
#     }
#   }
# }
# index = which(a == 1)
# set_combine_scale = set_combine_scale[,-(length(set_b_scale)+index-1)]
```
## Set b, response
```{r}
## transformation
suppressMessages(library(MASS))
suppressMessages(library(bestglm))
suppressMessages(library(dplyr))
hist(set_b_scale$response)
hist(log(set_b_scale$response))
set_b_log = mutate(y=log(response),.data = set_b_scale)#new y
set_b_log = select(set_b_log,-response)
```
```{r}
## full model
m_b = lm(response~., data = set_b_scale)
layout(matrix(data = c(1,2,3,4), ncol = 2, byrow = TRUE))
plot(m_b)
layout(1)
m0_b = lm(y ~ ., data = set_b_log)
layout(matrix(data = c(1,2,3,4), ncol = 2, byrow = TRUE))
plot(m0_b)
layout(1)
## model selection by AIC
require(car)
m1_b = lm(y ~ 1, data = set_b_log)#initial model
n = dim(set_b_log)[1]
b_aic_stepwise = step(object = m1_b, scope = formula(m0_b), direction="both",trace = 0)
g1<-function(x){
return(x)
}
source("GMC.R")
xb<- bestmodel$fitted.values
data<-cbind(g1(xb),bestmodel$model$y)#X,Y
GMC(data)#(GMC(X|Y),GMC(Y|X))
bestmodel<-b_aic_stepwise
g1<-function(x){
return(x)
}
source("GMC.R")
xb<- bestmodel$fitted.values
data<-cbind(g1(xb),bestmodel$model$y)#X,Y
GMC(data)#(GMC(X|Y),GMC(Y|X))
(initials<-bestmodel$coefficients)#initial beta
require(parallel)
#optimal beta
lambda.set<- seq(0,10,by = 0.1)
findopt<-function(lambda){
fn<-function(beta){
xb= as.matrix(bestmodel$model[-1]) %*% beta[-1]+beta[1]
data<-cbind(g1(xb),bestmodel$model$y)#X,Y
return(-GMC(data)[2]+ lambda*sum(beta))
}
opt<-optim(par = initials, fn =fn, method = "Nelder-Mead" )
return(c(lambda,opt$par,-opt$value))
}
OptEveryLambda<-t(sapply(lambda.set, FUN = findopt ));
OptEveryLambda<-mclapply(lambda.set, FUN = findopt,mc.cores=detectCores())
?outer
outer(1:3,4:6,function(x,y) x+y)
outer(1:3,4:6,function(x,y) max(c(x,y)))
outer(1:3,4:6,function(x,y) max(x,y))
?coutour
contour()
?contour
contour(1:3,4:5,z = x+y)
outer(1:3,1:3,FUN = function(x,y) x+y)
?outer
outer(1:3,1:3,FUN = function(x,y) x+y+10)
outer(1:3,1:3,FUN = function(x,y) x^2+y^2)
