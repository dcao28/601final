---
title: "final project"
output: html_document
---

## data preparation

```{r,eval=FALSE}
rm(list = ls())
#setwd("~/601final")
library(dplyr)
library(xlsx)
## data preprocessing 
set_b = read.csv("data/Set_b.csv", header = TRUE)
set_c = read.csv("data/Set_c.csv", header = TRUE) # set c has TP53
tp53 = read.xlsx("data/TP53.xlsx",sheetIndex = 1)##TP53
set_b = set_b[-which(set_b$response == 0),]
set_c = set_c[-which(set_c$response == 0),] # delete y=0
set_b_scale = data.frame(scale(set_b[,-1]))
set_b_scale$response = set_b$response
set_c_scale = data.frame(scale(set_c[,-1]))
set_c_scale$response = set_c$response # scale X

tp53 =tp53[-which(tp53$response == 0),] # delete the observation which has response equal to 0
tp53_scale = data.frame(scale(tp53[,-1]))

#View(set_c);View(set_b)
set_combine<-merge(set_b,set_c)
# set_combine = set_b
# set_combine[,length(set_b):(length(set_b)+length(set_c))] = set_c
set_combine_scale = data.frame(scale(set_combine[,-1]))
set_combine_scale$response = set_combine$response

# name_b = names(set_b_scale)
# name_c = names(set_c_scale)
# a = rep(0, length(name_c))
# for(i in 1:length(name_b)){
#   for(j in 1:length(name_c)){
#     if(name_c[j] == name_b[i]){
#       a[j] = 1
#     }
#   }
# }
# index = which(a == 1)
# set_combine_scale = set_combine_scale[,-(length(set_b_scale)+index-1)]
```

# 1.Set b, response


## BEST LM  

```{r,eval=TRUE}
load("./Rdata/b_aic_stepwise.RData")
bestmodel<-b_aic_stepwise
```

## GLM

*choose subdata by AIC model:b_aic_stepwise*  


```{r,eval=FALSE}
dd.log<- bestmodel$model
dd.log<- cbind(select(dd.log,-y),select(dd.log,y))
```


*logit*

```{r,eval=FALSE}
hist(dd.log$y)#take 6.5 as thrshold
threshold<-6.5
dd.log<-mutate(dd.log,y=ifelse(y<6.5,0,1))
#logit<-glm(y~.,dd.log,family = binomial)

bic.log<-bestglm(Xy = dd.log,
             family = binomial,
             IC = "BIC") # data should not be too big
bic$BestModel
```

## GMC  

find the optimal subset of X which make the $GMC(Y|X_{sub})$ or $GMC(Y|G(X_{sub}))$ largest!

subset: from the previous results  
link function(g())


$$Maximize~~GMC(Y|g(X))-lambda (lasso)$$

$$g(x)=x\\ linear~~ model$$ 

```{r,eval=TRUE}
g1<-function(x){
  return(x)
}
source("Script/GMC.R")
xb<- bestmodel$fitted.values
data<-cbind(g1(xb),bestmodel$model$y)#X,Y
GMC(data)#(GMC(X|Y),GMC(Y|X))
```


```{r,eval=TRUE}
#optimal beta
(initials<-bestmodel$coefficients)#initial beta  
require(parallel)
#optimal beta
rnge<- seq(0,2,by = 0.5)#lambda range
lambda1<- as.vector(sapply(rnge, function(x) rep(x,length(rnge))))
lambda2<- rnge
lambda.set <- rbind(lambda1, lambda2)
lambda.set <- as.data.frame(lambda.set);dim(lambda.set)

findopt<-function(lambda){
  lambda1<-lambda[1];lambda2<-lambda[2]
  fn<-function(beta){
  xb= as.matrix(bestmodel$model[-1]) %*% beta[-1]+beta[1]
  fit.n<-g1(xb)
  resid<-bestmodel$model$y- fit.n
  data<-cbind(fit.n,bestmodel$model$y)#X,Y
  return(-GMC(data)[2]+ lambda1*var(fit.n,resid)+lambda2*sum(abs(beta)))
 }
  
  opt<-optim(par = initials, fn =fn, method = "Nelder-Mead" )
  return(c(lambda,opt$par,-opt$value))
}

OptEveryLambda1_b<-mclapply(lambda.set, FUN = findopt,mc.cores=4)
class(OptEveryLambda1_b)
save(OptEveryLambda1_b, file = "Rdata/OptEveryLambda1_b.RData")
#colnames(OpetEveryLambda)[c(1,2,)]<- c("lambda1","lambda2","GMC(Y|G(X))+lasso")

optgmc<-sapply(OptEveryLambda1_b, function(x) return(x[c(length(x))]))
(optgmc<- OptEveryLambda1_b[[which.max(optgmc)]])

xb<- as.matrix(bestmodel$model[-1]) %*% optgmc[c(-1,-2,-3,-length(optgmc))] + optgmc[3]
fit.n<-g1(xb)
data<-cbind(fit.n, bestmodel$model$y)#X,Y
(gmc <- GMC(data)[2])
```  


$$g(x)= e^x Poisson~~ regression$$  

```{r,eval=TRUE}
g2<-function(x){
  return(exp(x))
}

data<-cbind(g2(bestmodel$fitted.values),bestmodel$model$y)#X,Y
GMC(data)#(GMC(X|Y),GMC(Y|X)) 
```


```{r,eval=TRUE}
#require(parallel)
#optimal beta

findopt<-function(lambda){
  lambda1<-lambda[1];lambda2<-lambda[2]
  fn<-function(beta){
  xb= as.matrix(bestmodel$model[-1]) %*% beta[-1]+beta[1]
  fit.n<-g2(xb)
  resid<-bestmodel$model$y- fit.n
  data<-cbind(fit.n,bestmodel$model$y)#X,Y
  return(-GMC(data)[2]+ lambda1*var(fit.n,resid)+lambda2*sum(abs(beta)))
 }
  
  opt<-optim(par = initials, fn =fn, method = "Nelder-Mead" )
  return(c(lambda,opt$par,-opt$value))
}

OptEveryLambda2_b<-mclapply(lambda.set, FUN = findopt,mc.cores=4)
class(OptEveryLambda2_b)
save(OptEveryLambda2_b, file = "Rdata/OptEveryLambda2_b.RData")
#colnames(OpetEveryLambda)[c(1,2,)]<- c("lambda1","lambda2","GMC(Y|G(X))+lasso")

optgmc<-sapply(OptEveryLambda2_b, function(x) return(x[c(length(x))]))
(optgmc<- OptEveryLambda2_b[[which.max(optgmc)]])

xb<- as.matrix(bestmodel$model[-1]) %*% optgmc[c(-1,-2,-3,-length(optgmc))] + optgmc[3]
fit.n<-g1(xb)
data<-cbind(fit.n, bestmodel$model$y)#X,Y
(gmc <- GMC(data)[2])
```  

$$sin(x)$$  

```{r}
g3<-function(x){
  return(sin(x))
}


data<-cbind(g3(bestmodel$fitted.values),bestmodel$model$y)#X,Y
GMC(data)#(GMC(X|Y),GMC(Y|X)) 
#require(parallel)
#optimal beta

findopt<-function(lambda){
  lambda1<-lambda[1];lambda2<-lambda[2]
  fn<-function(beta){
  xb= as.matrix(bestmodel$model[-1]) %*% beta[-1]+beta[1]
  fit.n<-g3(xb)
  resid<-bestmodel$model$y- fit.n
  data<-cbind(fit.n,bestmodel$model$y)#X,Y
  return(-GMC(data)[2]+ lambda1*var(fit.n,resid)+lambda2*sum(abs(beta)))
 }
  
  opt<-optim(par = initials, fn =fn, method = "Nelder-Mead" )
  return(c(lambda,opt$par,-opt$value))
}

OptEveryLambda3_b<-mclapply(lambda.set, FUN = findopt,mc.cores=4)
class(OptEveryLambda3_b)
save(OptEveryLambda3_b, file = "Rdata/OptEveryLambda3_b.RData")
#colnames(OpetEveryLambda)[c(1,2,)]<- c("lambda1","lambda2","GMC(Y|G(X))+lasso")

optgmc<-sapply(OptEveryLambda3_b, function(x) return(x[c(length(x))]))
(optgmc<- OptEveryLambda3_b[[which.max(optgmc)]])

xb<- as.matrix(bestmodel$model[-1]) %*% optgmc[c(-1,-2,-3,-length(optgmc))] + optgmc[3]
fit.n<-g1(xb)
data<-cbind(fit.n, bestmodel$model$y)#X,Y
(gmc <- GMC(data)[2])

```

$$g(x)= x^2$$

```{r}
g4<-function(x){
  return(x^2)
}


data<-cbind(g4(bestmodel$fitted.values),bestmodel$model$y)#X,Y
GMC(data)#(GMC(X|Y),GMC(Y|X)) 
#require(parallel)
#optimal beta

findopt<-function(lambda){
  lambda1<-lambda[1];lambda2<-lambda[2]
  fn<-function(beta){
  xb= as.matrix(bestmodel$model[-1]) %*% beta[-1]+beta[1]
  fit.n<-g4(xb)
  resid<-bestmodel$model$y- fit.n
  data<-cbind(fit.n,bestmodel$model$y)#X,Y
  return(-GMC(data)[2]+ lambda1*var(fit.n,resid)+lambda2*sum(abs(beta)))
 }
  
  opt<-optim(par = initials, fn =fn, method = "Nelder-Mead" )
  return(c(lambda,opt$par,-opt$value))
}

OptEveryLambda4_b<-mclapply(lambda.set, FUN = findopt,mc.cores=4)
class(OptEveryLambda4_b)
save(OptEveryLambda4_b, file = "Rdata/OptEveryLambda4_b.RData")
#colnames(OpetEveryLambda)[c(1,2,)]<- c("lambda1","lambda2","GMC(Y|G(X))+lasso")

optgmc<-sapply(OptEveryLambda4_b, function(x) return(x[c(length(x))]))
(optgmc<- OptEveryLambda4_b[[which.max(optgmc)]])

xb<- as.matrix(bestmodel$model[-1]) %*% optgmc[c(-1,-2,-3,-length(optgmc))] + optgmc[3]
fit.n<-g1(xb)
data<-cbind(fit.n, bestmodel$model$y)#X,Y
(gmc <- GMC(data)[2])

```  


$$g(x)=x^3$$

```{r}
g5<-function(x){
  return(x^3)
}


data<-cbind(g4(bestmodel$fitted.values),bestmodel$model$y)#X,Y
GMC(data)#(GMC(X|Y),GMC(Y|X)) 
#require(parallel)
#optimal beta

findopt<-function(lambda){
  lambda1<-lambda[1];lambda2<-lambda[2]
  fn<-function(beta){
  xb= as.matrix(bestmodel$model[-1]) %*% beta[-1]+beta[1]
  fit.n<-g5(xb)
  resid<-bestmodel$model$y- fit.n
  data<-cbind(fit.n,bestmodel$model$y)#X,Y
  return(-GMC(data)[2]+ lambda1*var(fit.n,resid)+lambda2*sum(abs(beta)))
 }
  
  opt<-optim(par = initials, fn =fn, method = "Nelder-Mead" )
  return(c(lambda,opt$par,-opt$value))
}

OptEveryLambda5_b<-mclapply(lambda.set, FUN = findopt,mc.cores=4)
class(OptEveryLambda5_b)
save(OptEveryLambda5_b, file = "Rdata/OptEveryLambda5_b.RData")
#colnames(OpetEveryLambda)[c(1,2,)]<- c("lambda1","lambda2","GMC(Y|G(X))+lasso")

optgmc<-sapply(OptEveryLambda5_b, function(x) return(x[c(length(x))]))
(optgmc<- OptEveryLambda5_b[[which.max(optgmc)]])

xb<- as.matrix(bestmodel$model[-1]) %*% optgmc[c(-1,-2,-3,-length(optgmc))] + optgmc[3]
fit.n<-g1(xb)
data<-cbind(fit.n, bestmodel$model$y)#X,Y
(gmc <- GMC(data)[2])
```


# 2.Set C, response 

## BEST LM  

```{r,eval=TRUE}
load("./Rdata/c_aic_stepwise.RData")
bestmodel<-b_aic_stepwise
```

## GLM

*choose subdata by AIC model:b_aic_stepwise*  


```{r,eval=FALSE}
dd.log<- bestmodel$model
dd.log<- cbind(select(dd.log,-y),select(dd.log,y))
```


*logit*

```{r,eval=FALSE}
hist(dd.log$y)#take 6.5 as thrshold
threshold<-6.5
dd.log<-mutate(dd.log,y=ifelse(y<6.5,0,1))
#logit<-glm(y~.,dd.log,family = binomial)

bic.log<-bestglm(Xy = dd.log,
             family = binomial,
             IC = "BIC") # data should not be too big
bic$BestModel
```

## GMC  

find the optimal subset of X which make the $GMC(Y|X_{sub})$ or $GMC(Y|G(X_{sub}))$ largest!

subset: from the previous results  
link function(g())


$$Maximize~~GMC(Y|g(X))-lambda (lasso)$$

$$g(x)=x\\ linear~~ model$$ 

```{r,eval=TRUE}
g1<-function(x){
  return(x)
}
source("Script/GMC.R")
xb<- bestmodel$fitted.values
data<-cbind(g1(xb),bestmodel$model$y)#X,Y
GMC(data)#(GMC(X|Y),GMC(Y|X))
```


```{r,eval=TRUE}
#optimal beta
(initials<-bestmodel$coefficients)#initial beta  
require(parallel)
#optimal beta
rnge<- seq(0,2,by = 0.5)#lambda range
lambda1<- as.vector(sapply(rnge, function(x) rep(x,length(rnge))))
lambda2<- rnge
lambda.set <- rbind(lambda1, lambda2)
lambda.set <- as.data.frame(lambda.set);dim(lambda.set)

findopt<-function(lambda){
  lambda1<-lambda[1];lambda2<-lambda[2]
  fn<-function(beta){
  xb= as.matrix(bestmodel$model[-1]) %*% beta[-1]+beta[1]
  fit.n<-g1(xb)
  resid<-bestmodel$model$y- fit.n
  data<-cbind(fit.n,bestmodel$model$y)#X,Y
  return(-GMC(data)[2]+ lambda1*var(fit.n,resid)+lambda2*sum(abs(beta)))
 }
  
  opt<-optim(par = initials, fn =fn, method = "Nelder-Mead" )
  return(c(lambda,opt$par,-opt$value))
}

OptEveryLambda1_c<-mclapply(lambda.set, FUN = findopt,mc.cores=4)
class(OptEveryLambda1_c)
save(OptEveryLambda1_c, file = "Rdata/OptEveryLambda1_c.RData")
#colnames(OpetEveryLambda)[c(1,2,)]<- c("lambda1","lambda2","GMC(Y|G(X))+lasso")

optgmc<-sapply(OptEveryLambda1_c, function(x) return(x[c(length(x))]))
(optgmc<- OptEveryLambda1_c[[which.max(optgmc)]])

xb<- as.matrix(bestmodel$model[-1]) %*% optgmc[c(-1,-2,-3,-length(optgmc))] + optgmc[3]
fit.n<-g1(xb)
data<-cbind(fit.n, bestmodel$model$y)#X,Y
(gmc <- GMC(data)[2])
```  


$$g(x)= e^x Poisson~~ regression$$  

```{r,eval=TRUE}
g2<-function(x){
  return(exp(x))
}

data<-cbind(g2(bestmodel$fitted.values),bestmodel$model$y)#X,Y
GMC(data)#(GMC(X|Y),GMC(Y|X)) 
```


```{r,eval=TRUE}
#require(parallel)
#optimal beta

findopt<-function(lambda){
  lambda1<-lambda[1];lambda2<-lambda[2]
  fn<-function(beta){
  xb= as.matrix(bestmodel$model[-1]) %*% beta[-1]+beta[1]
  fit.n<-g2(xb)
  resid<-bestmodel$model$y- fit.n
  data<-cbind(fit.n,bestmodel$model$y)#X,Y
  return(-GMC(data)[2]+ lambda1*var(fit.n,resid)+lambda2*sum(abs(beta)))
 }
  
  opt<-optim(par = initials, fn =fn, method = "Nelder-Mead" )
  return(c(lambda,opt$par,-opt$value))
}

OptEveryLambda2_c<-mclapply(lambda.set, FUN = findopt,mc.cores=4)
class(OptEveryLambda2_c)
save(OptEveryLambda2_c, file = "Rdata/OptEveryLambda2_c.RData")
#colnames(OpetEveryLambda)[c(1,2,)]<- c("lambda1","lambda2","GMC(Y|G(X))+lasso")

optgmc<-sapply(OptEveryLambda2_c, function(x) return(x[c(length(x))]))
(optgmc<- OptEveryLambda2_c[[which.max(optgmc)]])

xb<- as.matrix(bestmodel$model[-1]) %*% optgmc[c(-1,-2,-3,-length(optgmc))] + optgmc[3]
fit.n<-g1(xb)
data<-cbind(fit.n, bestmodel$model$y)#X,Y
(gmc <- GMC(data)[2])
```  

$$sin(x)$$  

```{r}
g3<-function(x){
  return(sin(x))
}


data<-cbind(g3(bestmodel$fitted.values),bestmodel$model$y)#X,Y
GMC(data)#(GMC(X|Y),GMC(Y|X)) 
#require(parallel)
#optimal beta

findopt<-function(lambda){
  lambda1<-lambda[1];lambda2<-lambda[2]
  fn<-function(beta){
  xb= as.matrix(bestmodel$model[-1]) %*% beta[-1]+beta[1]
  fit.n<-g3(xb)
  resid<-bestmodel$model$y- fit.n
  data<-cbind(fit.n,bestmodel$model$y)#X,Y
  return(-GMC(data)[2]+ lambda1*var(fit.n,resid)+lambda2*sum(abs(beta)))
 }
  
  opt<-optim(par = initials, fn =fn, method = "Nelder-Mead" )
  return(c(lambda,opt$par,-opt$value))
}

OptEveryLambda3_c<-mclapply(lambda.set, FUN = findopt,mc.cores=4)
class(OptEveryLambda3_c)
save(OptEveryLambda3_c, file = "Rdata/OptEveryLambda3_c.RData")
#colnames(OpetEveryLambda)[c(1,2,)]<- c("lambda1","lambda2","GMC(Y|G(X))+lasso")

optgmc<-sapply(OptEveryLambda3_c, function(x) return(x[c(length(x))]))
(optgmc<- OptEveryLambda3_c[[which.max(optgmc)]])

xb<- as.matrix(bestmodel$model[-1]) %*% optgmc[c(-1,-2,-3,-length(optgmc))] + optgmc[3]
fit.n<-g1(xb)
data<-cbind(fit.n, bestmodel$model$y)#X,Y
(gmc <- GMC(data)[2])

```

$$g(x)= x^2$$

```{r}
g4<-function(x){
  return(x^2)
}


data<-cbind(g4(bestmodel$fitted.values),bestmodel$model$y)#X,Y
GMC(data)#(GMC(X|Y),GMC(Y|X)) 
#require(parallel)
#optimal beta

findopt<-function(lambda){
  lambda1<-lambda[1];lambda2<-lambda[2]
  fn<-function(beta){
  xb= as.matrix(bestmodel$model[-1]) %*% beta[-1]+beta[1]
  fit.n<-g4(xb)
  resid<-bestmodel$model$y- fit.n
  data<-cbind(fit.n,bestmodel$model$y)#X,Y
  return(-GMC(data)[2]+ lambda1*var(fit.n,resid)+lambda2*sum(abs(beta)))
 }
  
  opt<-optim(par = initials, fn =fn, method = "Nelder-Mead" )
  return(c(lambda,opt$par,-opt$value))
}

OptEveryLambda4_c<-mclapply(lambda.set, FUN = findopt,mc.cores=4)
class(OptEveryLambda4_c)
save(OptEveryLambda4_c, file = "Rdata/OptEveryLambda4_c.RData")
#colnames(OpetEveryLambda)[c(1,2,)]<- c("lambda1","lambda2","GMC(Y|G(X))+lasso")

optgmc<-sapply(OptEveryLambda4_c, function(x) return(x[c(length(x))]))
(optgmc<- OptEveryLambda4_c[[which.max(optgmc)]])

xb<- as.matrix(bestmodel$model[-1]) %*% optgmc[c(-1,-2,-3,-length(optgmc))] + optgmc[3]
fit.n<-g1(xb)
data<-cbind(fit.n, bestmodel$model$y)#X,Y
(gmc <- GMC(data)[2])

```  


$$g(x)=x^3$$

```{r}
g5<-function(x){
  return(x^3)
}


data<-cbind(g4(bestmodel$fitted.values),bestmodel$model$y)#X,Y
GMC(data)#(GMC(X|Y),GMC(Y|X)) 
#require(parallel)
#optimal beta

findopt<-function(lambda){
  lambda1<-lambda[1];lambda2<-lambda[2]
  fn<-function(beta){
  xb= as.matrix(bestmodel$model[-1]) %*% beta[-1]+beta[1]
  fit.n<-g5(xb)
  resid<-bestmodel$model$y- fit.n
  data<-cbind(fit.n,bestmodel$model$y)#X,Y
  return(-GMC(data)[2]+ lambda1*var(fit.n,resid)+lambda2*sum(abs(beta)))
 }
  
  opt<-optim(par = initials, fn =fn, method = "Nelder-Mead" )
  return(c(lambda,opt$par,-opt$value))
}

OptEveryLambda5_c<-mclapply(lambda.set, FUN = findopt,mc.cores=4)
class(OptEveryLambda5_c)
save(OptEveryLambda5_c, file = "Rdata/OptEveryLambda5_c.RData")
#colnames(OpetEveryLambda)[c(1,2,)]<- c("lambda1","lambda2","GMC(Y|G(X))+lasso")

optgmc<-sapply(OptEveryLambda5_c, function(x) return(x[c(length(x))]))
(optgmc<- OptEveryLambda5_c[[which.max(optgmc)]])

xb<- as.matrix(bestmodel$model[-1]) %*% optgmc[c(-1,-2,-3,-length(optgmc))] + optgmc[3]
fit.n<-g1(xb)
data<-cbind(fit.n, bestmodel$model$y)#X,Y
(gmc <- GMC(data)[2])
```

# 3.Set b, TP53   

## BEST LM  

```{r,eval=TRUE}
load("./Rdata/b_aic_forward_t.RData")
bestmodel<-b_aic_stepwise
```

## GLM

*choose subdata by AIC model:b_aic_stepwise*  


```{r,eval=FALSE}
dd.log<- bestmodel$model
dd.log<- cbind(select(dd.log,-y),select(dd.log,y))
```


*logit*

```{r,eval=FALSE}
hist(dd.log$y)#take 6.5 as thrshold
threshold<-6.5
dd.log<-mutate(dd.log,y=ifelse(y<6.5,0,1))
#logit<-glm(y~.,dd.log,family = binomial)

bic.log<-bestglm(Xy = dd.log,
             family = binomial,
             IC = "BIC") # data should not be too big
bic$BestModel
```

## GMC  

find the optimal subset of X which make the $GMC(Y|X_{sub})$ or $GMC(Y|G(X_{sub}))$ largest!

subset: from the previous results  
link function(g())


$$Maximize~~GMC(Y|g(X))-lambda (lasso)$$

$$g(x)=x\\ linear~~ model$$ 

```{r,eval=TRUE}
g1<-function(x){
  return(x)
}
source("Script/GMC.R")
xb<- bestmodel$fitted.values
data<-cbind(g1(xb),bestmodel$model$y)#X,Y
GMC(data)#(GMC(X|Y),GMC(Y|X))
```


```{r,eval=TRUE}
#optimal beta
(initials<-bestmodel$coefficients)#initial beta  
require(parallel)
#optimal beta
rnge<- seq(0,2,by = 0.5)#lambda range
lambda1<- as.vector(sapply(rnge, function(x) rep(x,length(rnge))))
lambda2<- rnge
lambda.set <- rbind(lambda1, lambda2)
lambda.set <- as.data.frame(lambda.set);dim(lambda.set)

findopt<-function(lambda){
  lambda1<-lambda[1];lambda2<-lambda[2]
  fn<-function(beta){
  xb= as.matrix(bestmodel$model[-1]) %*% beta[-1]+beta[1]
  fit.n<-g1(xb)
  resid<-bestmodel$model$y- fit.n
  data<-cbind(fit.n,bestmodel$model$y)#X,Y
  return(-GMC(data)[2]+ lambda1*var(fit.n,resid)+lambda2*sum(abs(beta)))
 }
  
  opt<-optim(par = initials, fn =fn, method = "Nelder-Mead" )
  return(c(lambda,opt$par,-opt$value))
}

OptEveryLambda1_b<-mclapply(lambda.set, FUN = findopt,mc.cores=4)
class(OptEveryLambda1_b)
save(OptEveryLambda1_b, file = "Rdata/OptEveryLambda1_b.RData")
#colnames(OpetEveryLambda)[c(1,2,)]<- c("lambda1","lambda2","GMC(Y|G(X))+lasso")

optgmc<-sapply(OptEveryLambda1_b, function(x) return(x[c(length(x))]))
(optgmc<- OptEveryLambda1_b[[which.max(optgmc)]])

xb<- as.matrix(bestmodel$model[-1]) %*% optgmc[c(-1,-2,-3,-length(optgmc))] + optgmc[3]
fit.n<-g1(xb)
data<-cbind(fit.n, bestmodel$model$y)#X,Y
(gmc <- GMC(data)[2])
```  


$$g(x)= e^x Poisson~~ regression$$  

```{r,eval=TRUE}
g2<-function(x){
  return(exp(x))
}

data<-cbind(g2(bestmodel$fitted.values),bestmodel$model$y)#X,Y
GMC(data)#(GMC(X|Y),GMC(Y|X)) 
```


```{r,eval=TRUE}
#require(parallel)
#optimal beta

findopt<-function(lambda){
  lambda1<-lambda[1];lambda2<-lambda[2]
  fn<-function(beta){
  xb= as.matrix(bestmodel$model[-1]) %*% beta[-1]+beta[1]
  fit.n<-g2(xb)
  resid<-bestmodel$model$y- fit.n
  data<-cbind(fit.n,bestmodel$model$y)#X,Y
  return(-GMC(data)[2]+ lambda1*var(fit.n,resid)+lambda2*sum(abs(beta)))
 }
  
  opt<-optim(par = initials, fn =fn, method = "Nelder-Mead" )
  return(c(lambda,opt$par,-opt$value))
}

OptEveryLambda2_b<-mclapply(lambda.set, FUN = findopt,mc.cores=4)
class(OptEveryLambda2_b)
save(OptEveryLambda2_b, file = "Rdata/OptEveryLambda2_b.RData")
#colnames(OpetEveryLambda)[c(1,2,)]<- c("lambda1","lambda2","GMC(Y|G(X))+lasso")

optgmc<-sapply(OptEveryLambda2_b, function(x) return(x[c(length(x))]))
(optgmc<- OptEveryLambda2_b[[which.max(optgmc)]])

xb<- as.matrix(bestmodel$model[-1]) %*% optgmc[c(-1,-2,-3,-length(optgmc))] + optgmc[3]
fit.n<-g1(xb)
data<-cbind(fit.n, bestmodel$model$y)#X,Y
(gmc <- GMC(data)[2])
```  

$$sin(x)$$  

```{r}
g3<-function(x){
  return(sin(x))
}


data<-cbind(g3(bestmodel$fitted.values),bestmodel$model$y)#X,Y
GMC(data)#(GMC(X|Y),GMC(Y|X)) 
#require(parallel)
#optimal beta

findopt<-function(lambda){
  lambda1<-lambda[1];lambda2<-lambda[2]
  fn<-function(beta){
  xb= as.matrix(bestmodel$model[-1]) %*% beta[-1]+beta[1]
  fit.n<-g3(xb)
  resid<-bestmodel$model$y- fit.n
  data<-cbind(fit.n,bestmodel$model$y)#X,Y
  return(-GMC(data)[2]+ lambda1*var(fit.n,resid)+lambda2*sum(abs(beta)))
 }
  
  opt<-optim(par = initials, fn =fn, method = "Nelder-Mead" )
  return(c(lambda,opt$par,-opt$value))
}

OptEveryLambda3_b<-mclapply(lambda.set, FUN = findopt,mc.cores=4)
class(OptEveryLambda3_b)
save(OptEveryLambda3_b, file = "Rdata/OptEveryLambda3_b.RData")
#colnames(OpetEveryLambda)[c(1,2,)]<- c("lambda1","lambda2","GMC(Y|G(X))+lasso")

optgmc<-sapply(OptEveryLambda3_b, function(x) return(x[c(length(x))]))
(optgmc<- OptEveryLambda3_b[[which.max(optgmc)]])

xb<- as.matrix(bestmodel$model[-1]) %*% optgmc[c(-1,-2,-3,-length(optgmc))] + optgmc[3]
fit.n<-g1(xb)
data<-cbind(fit.n, bestmodel$model$y)#X,Y
(gmc <- GMC(data)[2])

```

$$g(x)= x^2$$

```{r}
g4<-function(x){
  return(x^2)
}


data<-cbind(g4(bestmodel$fitted.values),bestmodel$model$y)#X,Y
GMC(data)#(GMC(X|Y),GMC(Y|X)) 
#require(parallel)
#optimal beta

findopt<-function(lambda){
  lambda1<-lambda[1];lambda2<-lambda[2]
  fn<-function(beta){
  xb= as.matrix(bestmodel$model[-1]) %*% beta[-1]+beta[1]
  fit.n<-g4(xb)
  resid<-bestmodel$model$y- fit.n
  data<-cbind(fit.n,bestmodel$model$y)#X,Y
  return(-GMC(data)[2]+ lambda1*var(fit.n,resid)+lambda2*sum(abs(beta)))
 }
  
  opt<-optim(par = initials, fn =fn, method = "Nelder-Mead" )
  return(c(lambda,opt$par,-opt$value))
}

OptEveryLambda4_b<-mclapply(lambda.set, FUN = findopt,mc.cores=4)
class(OptEveryLambda4_b)
save(OptEveryLambda4_b, file = "Rdata/OptEveryLambda4_b.RData")
#colnames(OpetEveryLambda)[c(1,2,)]<- c("lambda1","lambda2","GMC(Y|G(X))+lasso")

optgmc<-sapply(OptEveryLambda4_b, function(x) return(x[c(length(x))]))
(optgmc<- OptEveryLambda4_b[[which.max(optgmc)]])

xb<- as.matrix(bestmodel$model[-1]) %*% optgmc[c(-1,-2,-3,-length(optgmc))] + optgmc[3]
fit.n<-g1(xb)
data<-cbind(fit.n, bestmodel$model$y)#X,Y
(gmc <- GMC(data)[2])

```  


$$g(x)=x^3$$

```{r}
g5<-function(x){
  return(x^3)
}


data<-cbind(g4(bestmodel$fitted.values),bestmodel$model$y)#X,Y
GMC(data)#(GMC(X|Y),GMC(Y|X)) 
#require(parallel)
#optimal beta

findopt<-function(lambda){
  lambda1<-lambda[1];lambda2<-lambda[2]
  fn<-function(beta){
  xb= as.matrix(bestmodel$model[-1]) %*% beta[-1]+beta[1]
  fit.n<-g5(xb)
  resid<-bestmodel$model$y- fit.n
  data<-cbind(fit.n,bestmodel$model$y)#X,Y
  return(-GMC(data)[2]+ lambda1*var(fit.n,resid)+lambda2*sum(abs(beta)))
 }
  
  opt<-optim(par = initials, fn =fn, method = "Nelder-Mead" )
  return(c(lambda,opt$par,-opt$value))
}

OptEveryLambda5_b<-mclapply(lambda.set, FUN = findopt,mc.cores=4)
class(OptEveryLambda5_b)
save(OptEveryLambda5_b, file = "Rdata/OptEveryLambda5_b.RData")
#colnames(OpetEveryLambda)[c(1,2,)]<- c("lambda1","lambda2","GMC(Y|G(X))+lasso")

optgmc<-sapply(OptEveryLambda5_b, function(x) return(x[c(length(x))]))
(optgmc<- OptEveryLambda5_b[[which.max(optgmc)]])

xb<- as.matrix(bestmodel$model[-1]) %*% optgmc[c(-1,-2,-3,-length(optgmc))] + optgmc[3]
fit.n<-g1(xb)
data<-cbind(fit.n, bestmodel$model$y)#X,Y
(gmc <- GMC(data)[2])
```

# 4.Set C, TP53 
## BEST LM  

```{r,eval=TRUE}
load("./Rdata/c_aic_stepwise_t.RData")
bestmodel<-b_aic_stepwise
```

## GLM

*choose subdata by AIC model:b_aic_stepwise*  


```{r,eval=FALSE}
dd.log<- bestmodel$model
dd.log<- cbind(select(dd.log,-y),select(dd.log,y))
```


*logit*

```{r,eval=FALSE}
hist(dd.log$y)#take 6.5 as thrshold
threshold<-6.5
dd.log<-mutate(dd.log,y=ifelse(y<6.5,0,1))
#logit<-glm(y~.,dd.log,family = binomial)

bic.log<-bestglm(Xy = dd.log,
             family = binomial,
             IC = "BIC") # data should not be too big
bic$BestModel
```

## GMC  

find the optimal subset of X which make the $GMC(Y|X_{sub})$ or $GMC(Y|G(X_{sub}))$ largest!

subset: from the previous results  
link function(g())


$$Maximize~~GMC(Y|g(X))-lambda (lasso)$$

$$g(x)=x\\ linear~~ model$$ 

```{r,eval=TRUE}
g1<-function(x){
  return(x)
}
source("Script/GMC.R")
xb<- bestmodel$fitted.values
data<-cbind(g1(xb),bestmodel$model$y)#X,Y
GMC(data)#(GMC(X|Y),GMC(Y|X))
```


```{r,eval=TRUE}
#optimal beta
(initials<-bestmodel$coefficients)#initial beta  
require(parallel)
#optimal beta
rnge<- seq(0,2,by = 0.5)#lambda range
lambda1<- as.vector(sapply(rnge, function(x) rep(x,length(rnge))))
lambda2<- rnge
lambda.set <- rbind(lambda1, lambda2)
lambda.set <- as.data.frame(lambda.set);dim(lambda.set)

findopt<-function(lambda){
  lambda1<-lambda[1];lambda2<-lambda[2]
  fn<-function(beta){
  xb= as.matrix(bestmodel$model[-1]) %*% beta[-1]+beta[1]
  fit.n<-g1(xb)
  resid<-bestmodel$model$y- fit.n
  data<-cbind(fit.n,bestmodel$model$y)#X,Y
  return(-GMC(data)[2]+ lambda1*var(fit.n,resid)+lambda2*sum(abs(beta)))
 }
  
  opt<-optim(par = initials, fn =fn, method = "Nelder-Mead" )
  return(c(lambda,opt$par,-opt$value))
}

OptEveryLambda1_b<-mclapply(lambda.set, FUN = findopt,mc.cores=4)
class(OptEveryLambda1_b)
save(OptEveryLambda1_b, file = "Rdata/OptEveryLambda1_b.RData")
#colnames(OpetEveryLambda)[c(1,2,)]<- c("lambda1","lambda2","GMC(Y|G(X))+lasso")

optgmc<-sapply(OptEveryLambda1_b, function(x) return(x[c(length(x))]))
(optgmc<- OptEveryLambda1_b[[which.max(optgmc)]])

xb<- as.matrix(bestmodel$model[-1]) %*% optgmc[c(-1,-2,-3,-length(optgmc))] + optgmc[3]
fit.n<-g1(xb)
data<-cbind(fit.n, bestmodel$model$y)#X,Y
(gmc <- GMC(data)[2])
```  


$$g(x)= e^x Poisson~~ regression$$  

```{r,eval=TRUE}
g2<-function(x){
  return(exp(x))
}

data<-cbind(g2(bestmodel$fitted.values),bestmodel$model$y)#X,Y
GMC(data)#(GMC(X|Y),GMC(Y|X)) 
```


```{r,eval=TRUE}
#require(parallel)
#optimal beta

findopt<-function(lambda){
  lambda1<-lambda[1];lambda2<-lambda[2]
  fn<-function(beta){
  xb= as.matrix(bestmodel$model[-1]) %*% beta[-1]+beta[1]
  fit.n<-g2(xb)
  resid<-bestmodel$model$y- fit.n
  data<-cbind(fit.n,bestmodel$model$y)#X,Y
  return(-GMC(data)[2]+ lambda1*var(fit.n,resid)+lambda2*sum(abs(beta)))
 }
  
  opt<-optim(par = initials, fn =fn, method = "Nelder-Mead" )
  return(c(lambda,opt$par,-opt$value))
}

OptEveryLambda2_b<-mclapply(lambda.set, FUN = findopt,mc.cores=4)
class(OptEveryLambda2_b)
save(OptEveryLambda2_b, file = "Rdata/OptEveryLambda2_b.RData")
#colnames(OpetEveryLambda)[c(1,2,)]<- c("lambda1","lambda2","GMC(Y|G(X))+lasso")

optgmc<-sapply(OptEveryLambda2_b, function(x) return(x[c(length(x))]))
(optgmc<- OptEveryLambda2_b[[which.max(optgmc)]])

xb<- as.matrix(bestmodel$model[-1]) %*% optgmc[c(-1,-2,-3,-length(optgmc))] + optgmc[3]
fit.n<-g1(xb)
data<-cbind(fit.n, bestmodel$model$y)#X,Y
(gmc <- GMC(data)[2])
```  

$$sin(x)$$  

```{r}
g3<-function(x){
  return(sin(x))
}


data<-cbind(g3(bestmodel$fitted.values),bestmodel$model$y)#X,Y
GMC(data)#(GMC(X|Y),GMC(Y|X)) 
#require(parallel)
#optimal beta

findopt<-function(lambda){
  lambda1<-lambda[1];lambda2<-lambda[2]
  fn<-function(beta){
  xb= as.matrix(bestmodel$model[-1]) %*% beta[-1]+beta[1]
  fit.n<-g3(xb)
  resid<-bestmodel$model$y- fit.n
  data<-cbind(fit.n,bestmodel$model$y)#X,Y
  return(-GMC(data)[2]+ lambda1*var(fit.n,resid)+lambda2*sum(abs(beta)))
 }
  
  opt<-optim(par = initials, fn =fn, method = "Nelder-Mead" )
  return(c(lambda,opt$par,-opt$value))
}

OptEveryLambda3_b<-mclapply(lambda.set, FUN = findopt,mc.cores=4)
class(OptEveryLambda3_b)
save(OptEveryLambda3_b, file = "Rdata/OptEveryLambda3_b.RData")
#colnames(OpetEveryLambda)[c(1,2,)]<- c("lambda1","lambda2","GMC(Y|G(X))+lasso")

optgmc<-sapply(OptEveryLambda3_b, function(x) return(x[c(length(x))]))
(optgmc<- OptEveryLambda3_b[[which.max(optgmc)]])

xb<- as.matrix(bestmodel$model[-1]) %*% optgmc[c(-1,-2,-3,-length(optgmc))] + optgmc[3]
fit.n<-g1(xb)
data<-cbind(fit.n, bestmodel$model$y)#X,Y
(gmc <- GMC(data)[2])

```

$$g(x)= x^2$$

```{r}
g4<-function(x){
  return(x^2)
}


data<-cbind(g4(bestmodel$fitted.values),bestmodel$model$y)#X,Y
GMC(data)#(GMC(X|Y),GMC(Y|X)) 
#require(parallel)
#optimal beta

findopt<-function(lambda){
  lambda1<-lambda[1];lambda2<-lambda[2]
  fn<-function(beta){
  xb= as.matrix(bestmodel$model[-1]) %*% beta[-1]+beta[1]
  fit.n<-g4(xb)
  resid<-bestmodel$model$y- fit.n
  data<-cbind(fit.n,bestmodel$model$y)#X,Y
  return(-GMC(data)[2]+ lambda1*var(fit.n,resid)+lambda2*sum(abs(beta)))
 }
  
  opt<-optim(par = initials, fn =fn, method = "Nelder-Mead" )
  return(c(lambda,opt$par,-opt$value))
}

OptEveryLambda4_b<-mclapply(lambda.set, FUN = findopt,mc.cores=4)
class(OptEveryLambda4_b)
save(OptEveryLambda4_b, file = "Rdata/OptEveryLambda4_b.RData")
#colnames(OpetEveryLambda)[c(1,2,)]<- c("lambda1","lambda2","GMC(Y|G(X))+lasso")

optgmc<-sapply(OptEveryLambda4_b, function(x) return(x[c(length(x))]))
(optgmc<- OptEveryLambda4_b[[which.max(optgmc)]])

xb<- as.matrix(bestmodel$model[-1]) %*% optgmc[c(-1,-2,-3,-length(optgmc))] + optgmc[3]
fit.n<-g1(xb)
data<-cbind(fit.n, bestmodel$model$y)#X,Y
(gmc <- GMC(data)[2])

```  


$$g(x)=x^3$$

```{r}
g5<-function(x){
  return(x^3)
}


data<-cbind(g4(bestmodel$fitted.values),bestmodel$model$y)#X,Y
GMC(data)#(GMC(X|Y),GMC(Y|X)) 
#require(parallel)
#optimal beta

findopt<-function(lambda){
  lambda1<-lambda[1];lambda2<-lambda[2]
  fn<-function(beta){
  xb= as.matrix(bestmodel$model[-1]) %*% beta[-1]+beta[1]
  fit.n<-g5(xb)
  resid<-bestmodel$model$y- fit.n
  data<-cbind(fit.n,bestmodel$model$y)#X,Y
  return(-GMC(data)[2]+ lambda1*var(fit.n,resid)+lambda2*sum(abs(beta)))
 }
  
  opt<-optim(par = initials, fn =fn, method = "Nelder-Mead" )
  return(c(lambda,opt$par,-opt$value))
}

OptEveryLambda5_b<-mclapply(lambda.set, FUN = findopt,mc.cores=4)
class(OptEveryLambda5_b)
save(OptEveryLambda5_b, file = "Rdata/OptEveryLambda5_b.RData")
#colnames(OpetEveryLambda)[c(1,2,)]<- c("lambda1","lambda2","GMC(Y|G(X))+lasso")

optgmc<-sapply(OptEveryLambda5_b, function(x) return(x[c(length(x))]))
(optgmc<- OptEveryLambda5_b[[which.max(optgmc)]])

xb<- as.matrix(bestmodel$model[-1]) %*% optgmc[c(-1,-2,-3,-length(optgmc))] + optgmc[3]
fit.n<-g1(xb)
data<-cbind(fit.n, bestmodel$model$y)#X,Y
(gmc <- GMC(data)[2])
```

# 5.Combine,response  

## BEST LM  

```{r,eval=TRUE}
load("./Rdata/combine_aic_stepwise.RData")
bestmodel<-b_aic_stepwise
```

## GLM

*choose subdata by AIC model:b_aic_stepwise*  


```{r,eval=FALSE}
dd.log<- bestmodel$model
dd.log<- cbind(select(dd.log,-y),select(dd.log,y))
```


*logit*

```{r,eval=FALSE}
hist(dd.log$y)#take 6.5 as thrshold
threshold<-6.5
dd.log<-mutate(dd.log,y=ifelse(y<6.5,0,1))
#logit<-glm(y~.,dd.log,family = binomial)

bic.log<-bestglm(Xy = dd.log,
             family = binomial,
             IC = "BIC") # data should not be too big
bic$BestModel
```

## GMC  

find the optimal subset of X which make the $GMC(Y|X_{sub})$ or $GMC(Y|G(X_{sub}))$ largest!

subset: from the previous results  
link function(g())


$$Maximize~~GMC(Y|g(X))-lambda (lasso)$$

$$g(x)=x\\ linear~~ model$$ 

```{r,eval=TRUE}
g1<-function(x){
  return(x)
}
source("Script/GMC.R")
xb<- bestmodel$fitted.values
data<-cbind(g1(xb),bestmodel$model$y)#X,Y
GMC(data)#(GMC(X|Y),GMC(Y|X))
```


```{r,eval=TRUE}
#optimal beta
(initials<-bestmodel$coefficients)#initial beta  
require(parallel)
#optimal beta
rnge<- seq(0,2,by = 0.5)#lambda range
lambda1<- as.vector(sapply(rnge, function(x) rep(x,length(rnge))))
lambda2<- rnge
lambda.set <- rbind(lambda1, lambda2)
lambda.set <- as.data.frame(lambda.set);dim(lambda.set)

findopt<-function(lambda){
  lambda1<-lambda[1];lambda2<-lambda[2]
  fn<-function(beta){
  xb= as.matrix(bestmodel$model[-1]) %*% beta[-1]+beta[1]
  fit.n<-g1(xb)
  resid<-bestmodel$model$y- fit.n
  data<-cbind(fit.n,bestmodel$model$y)#X,Y
  return(-GMC(data)[2]+ lambda1*var(fit.n,resid)+lambda2*sum(abs(beta)))
 }
  
  opt<-optim(par = initials, fn =fn, method = "Nelder-Mead" )
  return(c(lambda,opt$par,-opt$value))
}

OptEveryLambda1_b<-mclapply(lambda.set, FUN = findopt,mc.cores=4)
class(OptEveryLambda1_b)
save(OptEveryLambda1_b, file = "Rdata/OptEveryLambda1_b.RData")
#colnames(OpetEveryLambda)[c(1,2,)]<- c("lambda1","lambda2","GMC(Y|G(X))+lasso")

optgmc<-sapply(OptEveryLambda1_b, function(x) return(x[c(length(x))]))
(optgmc<- OptEveryLambda1_b[[which.max(optgmc)]])

xb<- as.matrix(bestmodel$model[-1]) %*% optgmc[c(-1,-2,-3,-length(optgmc))] + optgmc[3]
fit.n<-g1(xb)
data<-cbind(fit.n, bestmodel$model$y)#X,Y
(gmc <- GMC(data)[2])
```  


$$g(x)= e^x Poisson~~ regression$$  

```{r,eval=TRUE}
g2<-function(x){
  return(exp(x))
}

data<-cbind(g2(bestmodel$fitted.values),bestmodel$model$y)#X,Y
GMC(data)#(GMC(X|Y),GMC(Y|X)) 
```


```{r,eval=TRUE}
#require(parallel)
#optimal beta

findopt<-function(lambda){
  lambda1<-lambda[1];lambda2<-lambda[2]
  fn<-function(beta){
  xb= as.matrix(bestmodel$model[-1]) %*% beta[-1]+beta[1]
  fit.n<-g2(xb)
  resid<-bestmodel$model$y- fit.n
  data<-cbind(fit.n,bestmodel$model$y)#X,Y
  return(-GMC(data)[2]+ lambda1*var(fit.n,resid)+lambda2*sum(abs(beta)))
 }
  
  opt<-optim(par = initials, fn =fn, method = "Nelder-Mead" )
  return(c(lambda,opt$par,-opt$value))
}

OptEveryLambda2_b<-mclapply(lambda.set, FUN = findopt,mc.cores=4)
class(OptEveryLambda2_b)
save(OptEveryLambda2_b, file = "Rdata/OptEveryLambda2_b.RData")
#colnames(OpetEveryLambda)[c(1,2,)]<- c("lambda1","lambda2","GMC(Y|G(X))+lasso")

optgmc<-sapply(OptEveryLambda2_b, function(x) return(x[c(length(x))]))
(optgmc<- OptEveryLambda2_b[[which.max(optgmc)]])

xb<- as.matrix(bestmodel$model[-1]) %*% optgmc[c(-1,-2,-3,-length(optgmc))] + optgmc[3]
fit.n<-g1(xb)
data<-cbind(fit.n, bestmodel$model$y)#X,Y
(gmc <- GMC(data)[2])
```  

$$sin(x)$$  

```{r}
g3<-function(x){
  return(sin(x))
}


data<-cbind(g3(bestmodel$fitted.values),bestmodel$model$y)#X,Y
GMC(data)#(GMC(X|Y),GMC(Y|X)) 
#require(parallel)
#optimal beta

findopt<-function(lambda){
  lambda1<-lambda[1];lambda2<-lambda[2]
  fn<-function(beta){
  xb= as.matrix(bestmodel$model[-1]) %*% beta[-1]+beta[1]
  fit.n<-g3(xb)
  resid<-bestmodel$model$y- fit.n
  data<-cbind(fit.n,bestmodel$model$y)#X,Y
  return(-GMC(data)[2]+ lambda1*var(fit.n,resid)+lambda2*sum(abs(beta)))
 }
  
  opt<-optim(par = initials, fn =fn, method = "Nelder-Mead" )
  return(c(lambda,opt$par,-opt$value))
}

OptEveryLambda3_b<-mclapply(lambda.set, FUN = findopt,mc.cores=4)
class(OptEveryLambda3_b)
save(OptEveryLambda3_b, file = "Rdata/OptEveryLambda3_b.RData")
#colnames(OpetEveryLambda)[c(1,2,)]<- c("lambda1","lambda2","GMC(Y|G(X))+lasso")

optgmc<-sapply(OptEveryLambda3_b, function(x) return(x[c(length(x))]))
(optgmc<- OptEveryLambda3_b[[which.max(optgmc)]])

xb<- as.matrix(bestmodel$model[-1]) %*% optgmc[c(-1,-2,-3,-length(optgmc))] + optgmc[3]
fit.n<-g1(xb)
data<-cbind(fit.n, bestmodel$model$y)#X,Y
(gmc <- GMC(data)[2])

```

$$g(x)= x^2$$

```{r}
g4<-function(x){
  return(x^2)
}


data<-cbind(g4(bestmodel$fitted.values),bestmodel$model$y)#X,Y
GMC(data)#(GMC(X|Y),GMC(Y|X)) 
#require(parallel)
#optimal beta

findopt<-function(lambda){
  lambda1<-lambda[1];lambda2<-lambda[2]
  fn<-function(beta){
  xb= as.matrix(bestmodel$model[-1]) %*% beta[-1]+beta[1]
  fit.n<-g4(xb)
  resid<-bestmodel$model$y- fit.n
  data<-cbind(fit.n,bestmodel$model$y)#X,Y
  return(-GMC(data)[2]+ lambda1*var(fit.n,resid)+lambda2*sum(abs(beta)))
 }
  
  opt<-optim(par = initials, fn =fn, method = "Nelder-Mead" )
  return(c(lambda,opt$par,-opt$value))
}

OptEveryLambda4_b<-mclapply(lambda.set, FUN = findopt,mc.cores=4)
class(OptEveryLambda4_b)
save(OptEveryLambda4_b, file = "Rdata/OptEveryLambda4_b.RData")
#colnames(OpetEveryLambda)[c(1,2,)]<- c("lambda1","lambda2","GMC(Y|G(X))+lasso")

optgmc<-sapply(OptEveryLambda4_b, function(x) return(x[c(length(x))]))
(optgmc<- OptEveryLambda4_b[[which.max(optgmc)]])

xb<- as.matrix(bestmodel$model[-1]) %*% optgmc[c(-1,-2,-3,-length(optgmc))] + optgmc[3]
fit.n<-g1(xb)
data<-cbind(fit.n, bestmodel$model$y)#X,Y
(gmc <- GMC(data)[2])

```  


$$g(x)=x^3$$

```{r}
g5<-function(x){
  return(x^3)
}


data<-cbind(g4(bestmodel$fitted.values),bestmodel$model$y)#X,Y
GMC(data)#(GMC(X|Y),GMC(Y|X)) 
#require(parallel)
#optimal beta

findopt<-function(lambda){
  lambda1<-lambda[1];lambda2<-lambda[2]
  fn<-function(beta){
  xb= as.matrix(bestmodel$model[-1]) %*% beta[-1]+beta[1]
  fit.n<-g5(xb)
  resid<-bestmodel$model$y- fit.n
  data<-cbind(fit.n,bestmodel$model$y)#X,Y
  return(-GMC(data)[2]+ lambda1*var(fit.n,resid)+lambda2*sum(abs(beta)))
 }
  
  opt<-optim(par = initials, fn =fn, method = "Nelder-Mead" )
  return(c(lambda,opt$par,-opt$value))
}

OptEveryLambda5_b<-mclapply(lambda.set, FUN = findopt,mc.cores=4)
class(OptEveryLambda5_b)
save(OptEveryLambda5_b, file = "Rdata/OptEveryLambda5_b.RData")
#colnames(OpetEveryLambda)[c(1,2,)]<- c("lambda1","lambda2","GMC(Y|G(X))+lasso")

optgmc<-sapply(OptEveryLambda5_b, function(x) return(x[c(length(x))]))
(optgmc<- OptEveryLambda5_b[[which.max(optgmc)]])

xb<- as.matrix(bestmodel$model[-1]) %*% optgmc[c(-1,-2,-3,-length(optgmc))] + optgmc[3]
fit.n<-g1(xb)
data<-cbind(fit.n, bestmodel$model$y)#X,Y
(gmc <- GMC(data)[2])
```

# 6.Combine, TP53  

## BEST LM  

```{r,eval=TRUE}
load("./Rdata/combine_aic_forward_t.RData")
bestmodel<-b_aic_stepwise
```

## GLM

*choose subdata by AIC model:b_aic_stepwise*  


```{r,eval=FALSE}
dd.log<- bestmodel$model
dd.log<- cbind(select(dd.log,-y),select(dd.log,y))
```


*logit*

```{r,eval=FALSE}
hist(dd.log$y)#take 6.5 as thrshold
threshold<-6.5
dd.log<-mutate(dd.log,y=ifelse(y<6.5,0,1))
#logit<-glm(y~.,dd.log,family = binomial)

bic.log<-bestglm(Xy = dd.log,
             family = binomial,
             IC = "BIC") # data should not be too big
bic$BestModel
```

## GMC  

find the optimal subset of X which make the $GMC(Y|X_{sub})$ or $GMC(Y|G(X_{sub}))$ largest!

subset: from the previous results  
link function(g())


$$Maximize~~GMC(Y|g(X))-lambda (lasso)$$

$$g(x)=x\\ linear~~ model$$ 

```{r,eval=TRUE}
g1<-function(x){
  return(x)
}
source("Script/GMC.R")
xb<- bestmodel$fitted.values
data<-cbind(g1(xb),bestmodel$model$y)#X,Y
GMC(data)#(GMC(X|Y),GMC(Y|X))
```


```{r,eval=TRUE}
#optimal beta
(initials<-bestmodel$coefficients)#initial beta  
require(parallel)
#optimal beta
rnge<- seq(0,2,by = 0.5)#lambda range
lambda1<- as.vector(sapply(rnge, function(x) rep(x,length(rnge))))
lambda2<- rnge
lambda.set <- rbind(lambda1, lambda2)
lambda.set <- as.data.frame(lambda.set);dim(lambda.set)

findopt<-function(lambda){
  lambda1<-lambda[1];lambda2<-lambda[2]
  fn<-function(beta){
  xb= as.matrix(bestmodel$model[-1]) %*% beta[-1]+beta[1]
  fit.n<-g1(xb)
  resid<-bestmodel$model$y- fit.n
  data<-cbind(fit.n,bestmodel$model$y)#X,Y
  return(-GMC(data)[2]+ lambda1*var(fit.n,resid)+lambda2*sum(abs(beta)))
 }
  
  opt<-optim(par = initials, fn =fn, method = "Nelder-Mead" )
  return(c(lambda,opt$par,-opt$value))
}

OptEveryLambda1_b<-mclapply(lambda.set, FUN = findopt,mc.cores=4)
class(OptEveryLambda1_b)
save(OptEveryLambda1_b, file = "Rdata/OptEveryLambda1_b.RData")
#colnames(OpetEveryLambda)[c(1,2,)]<- c("lambda1","lambda2","GMC(Y|G(X))+lasso")

optgmc<-sapply(OptEveryLambda1_b, function(x) return(x[c(length(x))]))
(optgmc<- OptEveryLambda1_b[[which.max(optgmc)]])

xb<- as.matrix(bestmodel$model[-1]) %*% optgmc[c(-1,-2,-3,-length(optgmc))] + optgmc[3]
fit.n<-g1(xb)
data<-cbind(fit.n, bestmodel$model$y)#X,Y
(gmc <- GMC(data)[2])
```  


$$g(x)= e^x Poisson~~ regression$$  

```{r,eval=TRUE}
g2<-function(x){
  return(exp(x))
}

data<-cbind(g2(bestmodel$fitted.values),bestmodel$model$y)#X,Y
GMC(data)#(GMC(X|Y),GMC(Y|X)) 
```


```{r,eval=TRUE}
#require(parallel)
#optimal beta

findopt<-function(lambda){
  lambda1<-lambda[1];lambda2<-lambda[2]
  fn<-function(beta){
  xb= as.matrix(bestmodel$model[-1]) %*% beta[-1]+beta[1]
  fit.n<-g2(xb)
  resid<-bestmodel$model$y- fit.n
  data<-cbind(fit.n,bestmodel$model$y)#X,Y
  return(-GMC(data)[2]+ lambda1*var(fit.n,resid)+lambda2*sum(abs(beta)))
 }
  
  opt<-optim(par = initials, fn =fn, method = "Nelder-Mead" )
  return(c(lambda,opt$par,-opt$value))
}

OptEveryLambda2_b<-mclapply(lambda.set, FUN = findopt,mc.cores=4)
class(OptEveryLambda2_b)
save(OptEveryLambda2_b, file = "Rdata/OptEveryLambda2_b.RData")
#colnames(OpetEveryLambda)[c(1,2,)]<- c("lambda1","lambda2","GMC(Y|G(X))+lasso")

optgmc<-sapply(OptEveryLambda2_b, function(x) return(x[c(length(x))]))
(optgmc<- OptEveryLambda2_b[[which.max(optgmc)]])

xb<- as.matrix(bestmodel$model[-1]) %*% optgmc[c(-1,-2,-3,-length(optgmc))] + optgmc[3]
fit.n<-g1(xb)
data<-cbind(fit.n, bestmodel$model$y)#X,Y
(gmc <- GMC(data)[2])
```  

$$sin(x)$$  

```{r}
g3<-function(x){
  return(sin(x))
}


data<-cbind(g3(bestmodel$fitted.values),bestmodel$model$y)#X,Y
GMC(data)#(GMC(X|Y),GMC(Y|X)) 
#require(parallel)
#optimal beta

findopt<-function(lambda){
  lambda1<-lambda[1];lambda2<-lambda[2]
  fn<-function(beta){
  xb= as.matrix(bestmodel$model[-1]) %*% beta[-1]+beta[1]
  fit.n<-g3(xb)
  resid<-bestmodel$model$y- fit.n
  data<-cbind(fit.n,bestmodel$model$y)#X,Y
  return(-GMC(data)[2]+ lambda1*var(fit.n,resid)+lambda2*sum(abs(beta)))
 }
  
  opt<-optim(par = initials, fn =fn, method = "Nelder-Mead" )
  return(c(lambda,opt$par,-opt$value))
}

OptEveryLambda3_b<-mclapply(lambda.set, FUN = findopt,mc.cores=4)
class(OptEveryLambda3_b)
save(OptEveryLambda3_b, file = "Rdata/OptEveryLambda3_b.RData")
#colnames(OpetEveryLambda)[c(1,2,)]<- c("lambda1","lambda2","GMC(Y|G(X))+lasso")

optgmc<-sapply(OptEveryLambda3_b, function(x) return(x[c(length(x))]))
(optgmc<- OptEveryLambda3_b[[which.max(optgmc)]])

xb<- as.matrix(bestmodel$model[-1]) %*% optgmc[c(-1,-2,-3,-length(optgmc))] + optgmc[3]
fit.n<-g1(xb)
data<-cbind(fit.n, bestmodel$model$y)#X,Y
(gmc <- GMC(data)[2])

```

$$g(x)= x^2$$

```{r}
g4<-function(x){
  return(x^2)
}


data<-cbind(g4(bestmodel$fitted.values),bestmodel$model$y)#X,Y
GMC(data)#(GMC(X|Y),GMC(Y|X)) 
#require(parallel)
#optimal beta

findopt<-function(lambda){
  lambda1<-lambda[1];lambda2<-lambda[2]
  fn<-function(beta){
  xb= as.matrix(bestmodel$model[-1]) %*% beta[-1]+beta[1]
  fit.n<-g4(xb)
  resid<-bestmodel$model$y- fit.n
  data<-cbind(fit.n,bestmodel$model$y)#X,Y
  return(-GMC(data)[2]+ lambda1*var(fit.n,resid)+lambda2*sum(abs(beta)))
 }
  
  opt<-optim(par = initials, fn =fn, method = "Nelder-Mead" )
  return(c(lambda,opt$par,-opt$value))
}

OptEveryLambda4_b<-mclapply(lambda.set, FUN = findopt,mc.cores=4)
class(OptEveryLambda4_b)
save(OptEveryLambda4_b, file = "Rdata/OptEveryLambda4_b.RData")
#colnames(OpetEveryLambda)[c(1,2,)]<- c("lambda1","lambda2","GMC(Y|G(X))+lasso")

optgmc<-sapply(OptEveryLambda4_b, function(x) return(x[c(length(x))]))
(optgmc<- OptEveryLambda4_b[[which.max(optgmc)]])

xb<- as.matrix(bestmodel$model[-1]) %*% optgmc[c(-1,-2,-3,-length(optgmc))] + optgmc[3]
fit.n<-g1(xb)
data<-cbind(fit.n, bestmodel$model$y)#X,Y
(gmc <- GMC(data)[2])

```  


$$g(x)=x^3$$

```{r}
g5<-function(x){
  return(x^3)
}


data<-cbind(g4(bestmodel$fitted.values),bestmodel$model$y)#X,Y
GMC(data)#(GMC(X|Y),GMC(Y|X)) 
#require(parallel)
#optimal beta

findopt<-function(lambda){
  lambda1<-lambda[1];lambda2<-lambda[2]
  fn<-function(beta){
  xb= as.matrix(bestmodel$model[-1]) %*% beta[-1]+beta[1]
  fit.n<-g5(xb)
  resid<-bestmodel$model$y- fit.n
  data<-cbind(fit.n,bestmodel$model$y)#X,Y
  return(-GMC(data)[2]+ lambda1*var(fit.n,resid)+lambda2*sum(abs(beta)))
 }
  
  opt<-optim(par = initials, fn =fn, method = "Nelder-Mead" )
  return(c(lambda,opt$par,-opt$value))
}

OptEveryLambda5_b<-mclapply(lambda.set, FUN = findopt,mc.cores=4)
class(OptEveryLambda5_b)
save(OptEveryLambda5_b, file = "Rdata/OptEveryLambda5_b.RData")
#colnames(OpetEveryLambda)[c(1,2,)]<- c("lambda1","lambda2","GMC(Y|G(X))+lasso")

optgmc<-sapply(OptEveryLambda5_b, function(x) return(x[c(length(x))]))
(optgmc<- OptEveryLambda5_b[[which.max(optgmc)]])

xb<- as.matrix(bestmodel$model[-1]) %*% optgmc[c(-1,-2,-3,-length(optgmc))] + optgmc[3]
fit.n<-g1(xb)
data<-cbind(fit.n, bestmodel$model$y)#X,Y
(gmc <- GMC(data)[2])
```
